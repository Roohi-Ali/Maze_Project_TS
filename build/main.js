/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (() => {

eval("\nconst canvas = document.querySelector(\"canvas\");\nlet c = canvas.getContext(\"2d\");\nlet ctx = c;\nlet boy = new Image();\nboy.src = \"../build/boy.png\";\nlet home = new Image();\nhome.src = \"../build/house.png\";\nlet count = 0;\nlet raf;\nlet current;\nclass Maze {\n    constructor(size, rows, columns) {\n        this.size = size;\n        this.rows = rows;\n        this.columns = columns;\n        this.grid = [];\n        this.stack = [];\n        this.player = new Player(size, rows);\n    }\n    setup() {\n        for (let r = 0; r < this.rows; r++) {\n            let row = [];\n            for (let c = 0; c < this.columns; c++) {\n                let cell = new Cell(this.size, this.grid, this.rows, this.columns, r, c);\n                row.push(cell);\n            }\n            this.grid.push(row);\n        }\n        current = this.grid[0][0];\n        //call DFS algo\n        this.new_DFS();\n        //call draw_maze function\n        this.draw_maze();\n        this.player.draw();\n    }\n    draw_maze() {\n        canvas.width = this.size;\n        canvas.height = this.size;\n        canvas.style.backgroundColor = \"black\";\n        this.grid.forEach((row) => {\n            row.forEach((cell) => {\n                cell.display_cell();\n            });\n        });\n    }\n    new_DFS() {\n        current = this.grid[0][0];\n        current.visited = true;\n        this.stack.push(current);\n        while (this.stack.length != 0) {\n            let next = current.getRandomNeighbour();\n            if (next != undefined) {\n                next.visited = true;\n                this.stack.push(current);\n                current.removeWalls(current, next);\n                current = next;\n            }\n            else {\n                //if neighbour is undefined, then backtrack\n                if (this.stack.length > 0) {\n                    current = this.stack.pop();\n                }\n                else if (this.stack.length == 0) {\n                    return;\n                }\n            }\n        }\n        let start_cell = this.grid[0][0];\n        let end_cell = this.grid[this.rows - 1][this.columns - 1];\n        start_cell.walls.topWall = false;\n        end_cell.walls.rightWall = false;\n    }\n    moveDown() {\n        let playerCellPos = this.grid[this.player.y][this.player.x];\n        if (playerCellPos.walls.bottomWall == false) {\n            ctx.clearRect(0, 0, 500, 500);\n            this.draw_maze();\n            this.player.move(1, 0);\n        }\n    }\n    moveUp() {\n        let playerCellPos = this.grid[this.player.y][this.player.x];\n        if (playerCellPos.walls.topWall == false) {\n            ctx.clearRect(0, 0, 500, 500);\n            this.draw_maze();\n            this.player.move(-1, 0);\n        }\n    }\n    moveRight() {\n        let playerCellPos = this.grid[this.player.y][this.player.x];\n        if (playerCellPos.walls.rightWall == false) {\n            ctx.clearRect(0, 0, 500, 500);\n            this.draw_maze();\n            this.player.move(0, 1);\n        }\n    }\n    moveLeft() {\n        let playerCellPos = this.grid[this.player.y][this.player.x];\n        if (playerCellPos.walls.leftWall == false) {\n            ctx.clearRect(0, 0, 500, 500);\n            this.draw_maze();\n            this.player.move(0, -1);\n        }\n    }\n}\nclass Cell {\n    //color;\n    constructor(parentSize, parentGrid, rows, cols, rowNum, colNum) {\n        this.parentSize = parentSize;\n        this.parentGrid = parentGrid;\n        this.rows = rows;\n        this.cols = cols;\n        this.rowNum = rowNum;\n        this.colNum = colNum;\n        this.size = parentSize / rows;\n        this.walls = {\n            topWall: true,\n            bottomWall: true,\n            leftWall: true,\n            rightWall: true\n        };\n        this.visited = false;\n        this.neighbours = [];\n        //this.color = \"red\";\n    }\n    setNeighbours() {\n        this.neighbours = [];\n        let x = this.colNum;\n        let y = this.rowNum;\n        let left = (x !== 0) ? this.parentGrid[y][x - 1] : undefined;\n        let right = (x !== (this.cols - 1)) ? this.parentGrid[y][x + 1] : undefined;\n        let top = (y !== 0) ? this.parentGrid[y - 1][x] : undefined;\n        let bottom = (y !== (this.rows - 1)) ? this.parentGrid[y + 1][x] : undefined;\n        if (left && (left.visited == false)) {\n            this.neighbours.push(left);\n        }\n        if (right && (right.visited == false)) {\n            this.neighbours.push(right);\n        }\n        if (top && (top.visited == false)) {\n            this.neighbours.push(top);\n        }\n        if (bottom && (bottom.visited == false)) {\n            this.neighbours.push(bottom);\n        }\n    }\n    getRandomNeighbour() {\n        this.setNeighbours();\n        if (this.neighbours.length == 0) {\n            return undefined;\n        }\n        ;\n        let rand = Math.floor(Math.random() * this.neighbours.length);\n        return this.neighbours[rand];\n    }\n    drawLine(fromX, fromY, toX, toY) {\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = \"white\";\n        ctx.beginPath();\n        ctx.moveTo(fromX, fromY);\n        ctx.lineTo(toX, toY);\n        ctx.stroke();\n    }\n    drawWalls() {\n        //draw top wall\n        // let x = this.colNum*this.size;\n        // let y = this.rowNum*this.size;\n        let fromX = 0;\n        let fromY = 0;\n        let toX = 0;\n        let toY = 0;\n        if (this.walls.topWall) {\n            fromX = this.colNum * this.size;\n            fromY = this.rowNum * this.size;\n            toX = fromX + this.size;\n            toY = fromY;\n            this.drawLine(fromX, fromY, toX, toY);\n        }\n        if (this.walls.bottomWall) {\n            fromX = this.colNum * this.size;\n            fromY = (this.rowNum * this.size) + this.size;\n            toX = fromX + this.size;\n            toY = fromY;\n            this.drawLine(fromX, fromY, toX, toY);\n        }\n        if (this.walls.leftWall) {\n            fromX = this.colNum * this.size;\n            fromY = this.rowNum * this.size;\n            toX = fromX;\n            toY = fromY + this.size;\n            this.drawLine(fromX, fromY, toX, toY);\n        }\n        if (this.walls.rightWall) {\n            fromX = (this.colNum * this.size) + this.size;\n            fromY = this.rowNum * this.size;\n            toX = fromX;\n            toY = fromY + this.size;\n            this.drawLine(fromX, fromY, toX, toY);\n        }\n    }\n    // highlight(){\n    //     ctx.fillStyle = \"red\";\n    //     ctx.fillRect((this.colNum*this.size)+1,(this.rowNum*this.size)+1,this.size-2,this.size-2);  \n    // }\n    display_cell() {\n        this.drawWalls();\n        //ctx.fillStyle = this.color;\n        ctx.fillRect((this.colNum * this.size) + 1, (this.rowNum * this.size) + 1, this.size - 2, this.size - 2);\n    }\n    removeWalls(cell_1, cell_2) {\n        let XDiff = cell_2.colNum - cell_1.colNum;\n        let YDiff = cell_2.rowNum - cell_1.rowNum;\n        if (XDiff == 1) {\n            //remove cell1.rightWall cell2.leftWall\n            cell_1.walls.rightWall = false;\n            cell_2.walls.leftWall = false;\n        }\n        else if (XDiff == -1) {\n            //remove cell1.leftWall cell2.rightWall\n            cell_1.walls.leftWall = false;\n            cell_2.walls.rightWall = false;\n        }\n        if (YDiff == 1) {\n            cell_1.walls.bottomWall = false;\n            cell_2.walls.topWall = false;\n        }\n        else if (YDiff == -1) {\n            cell_1.walls.topWall = false;\n            cell_2.walls.bottomWall = false;\n        }\n    }\n}\n// let maze = new Maze(500,10,10);\n// maze.setup();\n// maze.draw();\nlet maze;\nlet start_time;\nlet end_time;\nfunction initialiseMaze(size, r, c) {\n    maze = new Maze(size, r, c);\n    start_time = Date.now();\n    //maze.makeNullGrid();\n    maze.setup();\n    //maze.draw();\n}\nconst btn = document.getElementById(\"submit_level\");\nbtn.addEventListener(\"click\", selectLevel);\nfunction selectLevel() {\n    const sel = document.querySelector(\"#level\");\n    if (sel.value == \"easy\") {\n        initialiseMaze(500, 10, 10);\n    }\n    else if (sel.value == \"medium\") {\n        initialiseMaze(500, 20, 20);\n    }\n    else if (sel.value == \"hard\") {\n        initialiseMaze(600, 30, 30);\n    }\n}\nclass Player {\n    constructor(parentSize, rows) {\n        this.x = 0;\n        this.y = 0;\n        this.parentSize = parentSize;\n        this.rows = rows;\n        this.cols = rows; //since its a square maze\n        this.size = parentSize / rows;\n        this.hasWon = false;\n        this.lastCell = rows - 1;\n        this.boyIcon = new Image();\n        this.boyIcon.src = \"../build/boy.png\";\n        this.homeIcon = new Image();\n        this.homeIcon.src = \"../build/house.png\";\n        this.steps = 0;\n    }\n    move(row, col) {\n        this.y += row;\n        this.x += col;\n        this.steps++;\n        this.draw();\n    }\n    IsWon() {\n        if ((this.x == this.lastCell) && (this.y == this.lastCell)) {\n            this.hasWon = true;\n            displaySteps(this.steps);\n            toggleVisibility();\n        }\n    }\n    draw() {\n        // this.boyIcon.src = \"boy.png\";\n        // this.homeIcon.src = \"house.png\";\n        ctx.beginPath();\n        ctx.drawImage(this.boyIcon, this.x * this.size, this.y * this.size, this.size, this.size);\n        ctx.drawImage(this.homeIcon, this.lastCell * this.size, this.lastCell * this.size, this.size, this.size);\n        // ctx.fillStyle=  \"blue\";\n        // ctx.fillRect(this.x*this.size,this.y*this.size,this.size-2,this.size-2);\n        // ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n        this.IsWon();\n    }\n}\ndocument.onkeydown = function (event) {\n    switch (event.code) {\n        case \"ArrowDown\": //40       \n            maze.moveDown();\n            break;\n        case \"ArrowUp\": //38\n            maze.moveUp();\n            break;\n        case \"ArrowLeft\": //37\n            maze.moveLeft();\n            break;\n        case \"ArrowRight\": //39\n            maze.moveRight();\n            break;\n    }\n};\nconst playAgainbtn = document.querySelector(\".btn\");\nplayAgainbtn.addEventListener(\"click\", reload);\nconst buttonClose1 = document.querySelector(\"#close1\");\nbuttonClose1.addEventListener(\"click\", toggleVisibility);\nconst buttonClose2 = document.querySelector(\"#close2\");\nbuttonClose2.addEventListener(\"click\", toggleInstrModal);\nconst okbtn = document.querySelector(\"#okbtn\");\nokbtn.addEventListener(\"click\", toggleInstrModal);\nfunction displaySteps(steps) {\n    const p_steps = document.getElementById(\"p_steps\");\n    let time_taken = TimeElapsed();\n    let str = `You have taken ${steps} steps to complete the game<br> Time taken: ${time_taken} seconds`;\n    p_steps.innerHTML = str;\n    // \"You have taken \"+ steps + \" steps to complete the game.\"\n}\nfunction toggleVisibility() {\n    const modal = document.querySelector(\".winDiv\");\n    const overlay = document.querySelector(\".overlay\");\n    modal.classList.toggle(\"hidden\");\n    overlay.classList.toggle(\"hidden\");\n}\nfunction toggleInstrModal() {\n    const modal_instr = document.querySelector(\".instr\");\n    const overlay_instr = document.querySelector(\".overlay\");\n    modal_instr.classList.toggle(\"hidden\");\n    overlay_instr.classList.toggle(\"hidden\");\n}\nfunction TimeElapsed() {\n    end_time = Date.now();\n    let timeTaken = Math.floor((end_time - start_time) / 1000);\n    return timeTaken;\n}\nwindow.onload = () => {\n    initialiseMaze(500, 10, 10);\n    toggleInstrModal();\n    // const canvas = document.querySelector(\"canvas\") as HTMLCanvasElement\n    // let c = canvas.getContext(\"2d\");\n};\nfunction reload() {\n    location.reload();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPLDZDQUE2QyxZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0X3R5cGVzY3JpcHQvLi9zcmMvaW5kZXgudHM/MjVlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIik7XG5sZXQgYyA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5sZXQgY3R4ID0gYztcbmxldCBib3kgPSBuZXcgSW1hZ2UoKTtcbmJveS5zcmMgPSBcIi4uL2J1aWxkL2JveS5wbmdcIjtcbmxldCBob21lID0gbmV3IEltYWdlKCk7XG5ob21lLnNyYyA9IFwiLi4vYnVpbGQvaG91c2UucG5nXCI7XG5sZXQgY291bnQgPSAwO1xubGV0IHJhZjtcbmxldCBjdXJyZW50O1xuY2xhc3MgTWF6ZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICB0aGlzLmdyaWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXIoc2l6ZSwgcm93cyk7XG4gICAgfVxuICAgIHNldHVwKCkge1xuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMucm93czsgcisrKSB7XG4gICAgICAgICAgICBsZXQgcm93ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY29sdW1uczsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSBuZXcgQ2VsbCh0aGlzLnNpemUsIHRoaXMuZ3JpZCwgdGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMsIHIsIGMpO1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gdGhpcy5ncmlkWzBdWzBdO1xuICAgICAgICAvL2NhbGwgREZTIGFsZ29cbiAgICAgICAgdGhpcy5uZXdfREZTKCk7XG4gICAgICAgIC8vY2FsbCBkcmF3X21hemUgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5kcmF3X21hemUoKTtcbiAgICAgICAgdGhpcy5wbGF5ZXIuZHJhdygpO1xuICAgIH1cbiAgICBkcmF3X21hemUoKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZTtcbiAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5ncmlkLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICAgICAgcm93LmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjZWxsLmRpc3BsYXlfY2VsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXdfREZTKCkge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5ncmlkWzBdWzBdO1xuICAgICAgICBjdXJyZW50LnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1cnJlbnQuZ2V0UmFuZG9tTmVpZ2hib3VyKCk7XG4gICAgICAgICAgICBpZiAobmV4dCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0LnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnJlbW92ZVdhbGxzKGN1cnJlbnQsIG5leHQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9pZiBuZWlnaGJvdXIgaXMgdW5kZWZpbmVkLCB0aGVuIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRfY2VsbCA9IHRoaXMuZ3JpZFswXVswXTtcbiAgICAgICAgbGV0IGVuZF9jZWxsID0gdGhpcy5ncmlkW3RoaXMucm93cyAtIDFdW3RoaXMuY29sdW1ucyAtIDFdO1xuICAgICAgICBzdGFydF9jZWxsLndhbGxzLnRvcFdhbGwgPSBmYWxzZTtcbiAgICAgICAgZW5kX2NlbGwud2FsbHMucmlnaHRXYWxsID0gZmFsc2U7XG4gICAgfVxuICAgIG1vdmVEb3duKCkge1xuICAgICAgICBsZXQgcGxheWVyQ2VsbFBvcyA9IHRoaXMuZ3JpZFt0aGlzLnBsYXllci55XVt0aGlzLnBsYXllci54XTtcbiAgICAgICAgaWYgKHBsYXllckNlbGxQb3Mud2FsbHMuYm90dG9tV2FsbCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCA1MDAsIDUwMCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdfbWF6ZSgpO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIubW92ZSgxLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlVXAoKSB7XG4gICAgICAgIGxldCBwbGF5ZXJDZWxsUG9zID0gdGhpcy5ncmlkW3RoaXMucGxheWVyLnldW3RoaXMucGxheWVyLnhdO1xuICAgICAgICBpZiAocGxheWVyQ2VsbFBvcy53YWxscy50b3BXYWxsID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIDUwMCwgNTAwKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd19tYXplKCk7XG4gICAgICAgICAgICB0aGlzLnBsYXllci5tb3ZlKC0xLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlUmlnaHQoKSB7XG4gICAgICAgIGxldCBwbGF5ZXJDZWxsUG9zID0gdGhpcy5ncmlkW3RoaXMucGxheWVyLnldW3RoaXMucGxheWVyLnhdO1xuICAgICAgICBpZiAocGxheWVyQ2VsbFBvcy53YWxscy5yaWdodFdhbGwgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgNTAwLCA1MDApO1xuICAgICAgICAgICAgdGhpcy5kcmF3X21hemUoKTtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLm1vdmUoMCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUxlZnQoKSB7XG4gICAgICAgIGxldCBwbGF5ZXJDZWxsUG9zID0gdGhpcy5ncmlkW3RoaXMucGxheWVyLnldW3RoaXMucGxheWVyLnhdO1xuICAgICAgICBpZiAocGxheWVyQ2VsbFBvcy53YWxscy5sZWZ0V2FsbCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCA1MDAsIDUwMCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdfbWF6ZSgpO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIubW92ZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDZWxsIHtcbiAgICAvL2NvbG9yO1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNpemUsIHBhcmVudEdyaWQsIHJvd3MsIGNvbHMsIHJvd051bSwgY29sTnVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50U2l6ZSA9IHBhcmVudFNpemU7XG4gICAgICAgIHRoaXMucGFyZW50R3JpZCA9IHBhcmVudEdyaWQ7XG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuY29scyA9IGNvbHM7XG4gICAgICAgIHRoaXMucm93TnVtID0gcm93TnVtO1xuICAgICAgICB0aGlzLmNvbE51bSA9IGNvbE51bTtcbiAgICAgICAgdGhpcy5zaXplID0gcGFyZW50U2l6ZSAvIHJvd3M7XG4gICAgICAgIHRoaXMud2FsbHMgPSB7XG4gICAgICAgICAgICB0b3BXYWxsOiB0cnVlLFxuICAgICAgICAgICAgYm90dG9tV2FsbDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZnRXYWxsOiB0cnVlLFxuICAgICAgICAgICAgcmlnaHRXYWxsOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5laWdoYm91cnMgPSBbXTtcbiAgICAgICAgLy90aGlzLmNvbG9yID0gXCJyZWRcIjtcbiAgICB9XG4gICAgc2V0TmVpZ2hib3VycygpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvdXJzID0gW107XG4gICAgICAgIGxldCB4ID0gdGhpcy5jb2xOdW07XG4gICAgICAgIGxldCB5ID0gdGhpcy5yb3dOdW07XG4gICAgICAgIGxldCBsZWZ0ID0gKHggIT09IDApID8gdGhpcy5wYXJlbnRHcmlkW3ldW3ggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJpZ2h0ID0gKHggIT09ICh0aGlzLmNvbHMgLSAxKSkgPyB0aGlzLnBhcmVudEdyaWRbeV1beCArIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdG9wID0gKHkgIT09IDApID8gdGhpcy5wYXJlbnRHcmlkW3kgLSAxXVt4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGJvdHRvbSA9ICh5ICE9PSAodGhpcy5yb3dzIC0gMSkpID8gdGhpcy5wYXJlbnRHcmlkW3kgKyAxXVt4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGxlZnQgJiYgKGxlZnQudmlzaXRlZCA9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3Vycy5wdXNoKGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCAmJiAocmlnaHQudmlzaXRlZCA9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3Vycy5wdXNoKHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wICYmICh0b3AudmlzaXRlZCA9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3Vycy5wdXNoKHRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSAmJiAoYm90dG9tLnZpc2l0ZWQgPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLm5laWdoYm91cnMucHVzaChib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJhbmRvbU5laWdoYm91cigpIHtcbiAgICAgICAgdGhpcy5zZXROZWlnaGJvdXJzKCk7XG4gICAgICAgIGlmICh0aGlzLm5laWdoYm91cnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBsZXQgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMubmVpZ2hib3Vycy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvdXJzW3JhbmRdO1xuICAgIH1cbiAgICBkcmF3TGluZShmcm9tWCwgZnJvbVksIHRvWCwgdG9ZKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tWCwgZnJvbVkpO1xuICAgICAgICBjdHgubGluZVRvKHRvWCwgdG9ZKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBkcmF3V2FsbHMoKSB7XG4gICAgICAgIC8vZHJhdyB0b3Agd2FsbFxuICAgICAgICAvLyBsZXQgeCA9IHRoaXMuY29sTnVtKnRoaXMuc2l6ZTtcbiAgICAgICAgLy8gbGV0IHkgPSB0aGlzLnJvd051bSp0aGlzLnNpemU7XG4gICAgICAgIGxldCBmcm9tWCA9IDA7XG4gICAgICAgIGxldCBmcm9tWSA9IDA7XG4gICAgICAgIGxldCB0b1ggPSAwO1xuICAgICAgICBsZXQgdG9ZID0gMDtcbiAgICAgICAgaWYgKHRoaXMud2FsbHMudG9wV2FsbCkge1xuICAgICAgICAgICAgZnJvbVggPSB0aGlzLmNvbE51bSAqIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGZyb21ZID0gdGhpcy5yb3dOdW0gKiB0aGlzLnNpemU7XG4gICAgICAgICAgICB0b1ggPSBmcm9tWCArIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIHRvWSA9IGZyb21ZO1xuICAgICAgICAgICAgdGhpcy5kcmF3TGluZShmcm9tWCwgZnJvbVksIHRvWCwgdG9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53YWxscy5ib3R0b21XYWxsKSB7XG4gICAgICAgICAgICBmcm9tWCA9IHRoaXMuY29sTnVtICogdGhpcy5zaXplO1xuICAgICAgICAgICAgZnJvbVkgPSAodGhpcy5yb3dOdW0gKiB0aGlzLnNpemUpICsgdGhpcy5zaXplO1xuICAgICAgICAgICAgdG9YID0gZnJvbVggKyB0aGlzLnNpemU7XG4gICAgICAgICAgICB0b1kgPSBmcm9tWTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2FsbHMubGVmdFdhbGwpIHtcbiAgICAgICAgICAgIGZyb21YID0gdGhpcy5jb2xOdW0gKiB0aGlzLnNpemU7XG4gICAgICAgICAgICBmcm9tWSA9IHRoaXMucm93TnVtICogdGhpcy5zaXplO1xuICAgICAgICAgICAgdG9YID0gZnJvbVg7XG4gICAgICAgICAgICB0b1kgPSBmcm9tWSArIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2FsbHMucmlnaHRXYWxsKSB7XG4gICAgICAgICAgICBmcm9tWCA9ICh0aGlzLmNvbE51bSAqIHRoaXMuc2l6ZSkgKyB0aGlzLnNpemU7XG4gICAgICAgICAgICBmcm9tWSA9IHRoaXMucm93TnVtICogdGhpcy5zaXplO1xuICAgICAgICAgICAgdG9YID0gZnJvbVg7XG4gICAgICAgICAgICB0b1kgPSBmcm9tWSArIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaGlnaGxpZ2h0KCl7XG4gICAgLy8gICAgIGN0eC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIC8vICAgICBjdHguZmlsbFJlY3QoKHRoaXMuY29sTnVtKnRoaXMuc2l6ZSkrMSwodGhpcy5yb3dOdW0qdGhpcy5zaXplKSsxLHRoaXMuc2l6ZS0yLHRoaXMuc2l6ZS0yKTsgIFxuICAgIC8vIH1cbiAgICBkaXNwbGF5X2NlbGwoKSB7XG4gICAgICAgIHRoaXMuZHJhd1dhbGxzKCk7XG4gICAgICAgIC8vY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgodGhpcy5jb2xOdW0gKiB0aGlzLnNpemUpICsgMSwgKHRoaXMucm93TnVtICogdGhpcy5zaXplKSArIDEsIHRoaXMuc2l6ZSAtIDIsIHRoaXMuc2l6ZSAtIDIpO1xuICAgIH1cbiAgICByZW1vdmVXYWxscyhjZWxsXzEsIGNlbGxfMikge1xuICAgICAgICBsZXQgWERpZmYgPSBjZWxsXzIuY29sTnVtIC0gY2VsbF8xLmNvbE51bTtcbiAgICAgICAgbGV0IFlEaWZmID0gY2VsbF8yLnJvd051bSAtIGNlbGxfMS5yb3dOdW07XG4gICAgICAgIGlmIChYRGlmZiA9PSAxKSB7XG4gICAgICAgICAgICAvL3JlbW92ZSBjZWxsMS5yaWdodFdhbGwgY2VsbDIubGVmdFdhbGxcbiAgICAgICAgICAgIGNlbGxfMS53YWxscy5yaWdodFdhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGNlbGxfMi53YWxscy5sZWZ0V2FsbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFhEaWZmID09IC0xKSB7XG4gICAgICAgICAgICAvL3JlbW92ZSBjZWxsMS5sZWZ0V2FsbCBjZWxsMi5yaWdodFdhbGxcbiAgICAgICAgICAgIGNlbGxfMS53YWxscy5sZWZ0V2FsbCA9IGZhbHNlO1xuICAgICAgICAgICAgY2VsbF8yLndhbGxzLnJpZ2h0V2FsbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChZRGlmZiA9PSAxKSB7XG4gICAgICAgICAgICBjZWxsXzEud2FsbHMuYm90dG9tV2FsbCA9IGZhbHNlO1xuICAgICAgICAgICAgY2VsbF8yLndhbGxzLnRvcFdhbGwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChZRGlmZiA9PSAtMSkge1xuICAgICAgICAgICAgY2VsbF8xLndhbGxzLnRvcFdhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGNlbGxfMi53YWxscy5ib3R0b21XYWxsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBsZXQgbWF6ZSA9IG5ldyBNYXplKDUwMCwxMCwxMCk7XG4vLyBtYXplLnNldHVwKCk7XG4vLyBtYXplLmRyYXcoKTtcbmxldCBtYXplO1xubGV0IHN0YXJ0X3RpbWU7XG5sZXQgZW5kX3RpbWU7XG5mdW5jdGlvbiBpbml0aWFsaXNlTWF6ZShzaXplLCByLCBjKSB7XG4gICAgbWF6ZSA9IG5ldyBNYXplKHNpemUsIHIsIGMpO1xuICAgIHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vbWF6ZS5tYWtlTnVsbEdyaWQoKTtcbiAgICBtYXplLnNldHVwKCk7XG4gICAgLy9tYXplLmRyYXcoKTtcbn1cbmNvbnN0IGJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3VibWl0X2xldmVsXCIpO1xuYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzZWxlY3RMZXZlbCk7XG5mdW5jdGlvbiBzZWxlY3RMZXZlbCgpIHtcbiAgICBjb25zdCBzZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xldmVsXCIpO1xuICAgIGlmIChzZWwudmFsdWUgPT0gXCJlYXN5XCIpIHtcbiAgICAgICAgaW5pdGlhbGlzZU1hemUoNTAwLCAxMCwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWwudmFsdWUgPT0gXCJtZWRpdW1cIikge1xuICAgICAgICBpbml0aWFsaXNlTWF6ZSg1MDAsIDIwLCAyMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbC52YWx1ZSA9PSBcImhhcmRcIikge1xuICAgICAgICBpbml0aWFsaXNlTWF6ZSg2MDAsIDMwLCAzMCk7XG4gICAgfVxufVxuY2xhc3MgUGxheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTaXplLCByb3dzKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMucGFyZW50U2l6ZSA9IHBhcmVudFNpemU7XG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuY29scyA9IHJvd3M7IC8vc2luY2UgaXRzIGEgc3F1YXJlIG1hemVcbiAgICAgICAgdGhpcy5zaXplID0gcGFyZW50U2l6ZSAvIHJvd3M7XG4gICAgICAgIHRoaXMuaGFzV29uID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdENlbGwgPSByb3dzIC0gMTtcbiAgICAgICAgdGhpcy5ib3lJY29uID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHRoaXMuYm95SWNvbi5zcmMgPSBcIi4uL2J1aWxkL2JveS5wbmdcIjtcbiAgICAgICAgdGhpcy5ob21lSWNvbiA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aGlzLmhvbWVJY29uLnNyYyA9IFwiLi4vYnVpbGQvaG91c2UucG5nXCI7XG4gICAgICAgIHRoaXMuc3RlcHMgPSAwO1xuICAgIH1cbiAgICBtb3ZlKHJvdywgY29sKSB7XG4gICAgICAgIHRoaXMueSArPSByb3c7XG4gICAgICAgIHRoaXMueCArPSBjb2w7XG4gICAgICAgIHRoaXMuc3RlcHMrKztcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuICAgIElzV29uKCkge1xuICAgICAgICBpZiAoKHRoaXMueCA9PSB0aGlzLmxhc3RDZWxsKSAmJiAodGhpcy55ID09IHRoaXMubGFzdENlbGwpKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dvbiA9IHRydWU7XG4gICAgICAgICAgICBkaXNwbGF5U3RlcHModGhpcy5zdGVwcyk7XG4gICAgICAgICAgICB0b2dnbGVWaXNpYmlsaXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgLy8gdGhpcy5ib3lJY29uLnNyYyA9IFwiYm95LnBuZ1wiO1xuICAgICAgICAvLyB0aGlzLmhvbWVJY29uLnNyYyA9IFwiaG91c2UucG5nXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmJveUljb24sIHRoaXMueCAqIHRoaXMuc2l6ZSwgdGhpcy55ICogdGhpcy5zaXplLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5ob21lSWNvbiwgdGhpcy5sYXN0Q2VsbCAqIHRoaXMuc2l6ZSwgdGhpcy5sYXN0Q2VsbCAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICAvLyBjdHguZmlsbFN0eWxlPSAgXCJibHVlXCI7XG4gICAgICAgIC8vIGN0eC5maWxsUmVjdCh0aGlzLngqdGhpcy5zaXplLHRoaXMueSp0aGlzLnNpemUsdGhpcy5zaXplLTIsdGhpcy5zaXplLTIpO1xuICAgICAgICAvLyBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5Jc1dvbigpO1xuICAgIH1cbn1cbmRvY3VtZW50Lm9ua2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IC8vNDAgICAgICAgXG4gICAgICAgICAgICBtYXplLm1vdmVEb3duKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjogLy8zOFxuICAgICAgICAgICAgbWF6ZS5tb3ZlVXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IC8vMzdcbiAgICAgICAgICAgIG1hemUubW92ZUxlZnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiAvLzM5XG4gICAgICAgICAgICBtYXplLm1vdmVSaWdodCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbmNvbnN0IHBsYXlBZ2FpbmJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnRuXCIpO1xucGxheUFnYWluYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCByZWxvYWQpO1xuY29uc3QgYnV0dG9uQ2xvc2UxID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjbG9zZTFcIik7XG5idXR0b25DbG9zZTEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvZ2dsZVZpc2liaWxpdHkpO1xuY29uc3QgYnV0dG9uQ2xvc2UyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjbG9zZTJcIik7XG5idXR0b25DbG9zZTIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvZ2dsZUluc3RyTW9kYWwpO1xuY29uc3Qgb2tidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI29rYnRuXCIpO1xub2tidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvZ2dsZUluc3RyTW9kYWwpO1xuZnVuY3Rpb24gZGlzcGxheVN0ZXBzKHN0ZXBzKSB7XG4gICAgY29uc3QgcF9zdGVwcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicF9zdGVwc1wiKTtcbiAgICBsZXQgdGltZV90YWtlbiA9IFRpbWVFbGFwc2VkKCk7XG4gICAgbGV0IHN0ciA9IGBZb3UgaGF2ZSB0YWtlbiAke3N0ZXBzfSBzdGVwcyB0byBjb21wbGV0ZSB0aGUgZ2FtZTxicj4gVGltZSB0YWtlbjogJHt0aW1lX3Rha2VufSBzZWNvbmRzYDtcbiAgICBwX3N0ZXBzLmlubmVySFRNTCA9IHN0cjtcbiAgICAvLyBcIllvdSBoYXZlIHRha2VuIFwiKyBzdGVwcyArIFwiIHN0ZXBzIHRvIGNvbXBsZXRlIHRoZSBnYW1lLlwiXG59XG5mdW5jdGlvbiB0b2dnbGVWaXNpYmlsaXR5KCkge1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi53aW5EaXZcIik7XG4gICAgY29uc3Qgb3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3ZlcmxheVwiKTtcbiAgICBtb2RhbC5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIpO1xuICAgIG92ZXJsYXkuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUluc3RyTW9kYWwoKSB7XG4gICAgY29uc3QgbW9kYWxfaW5zdHIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmluc3RyXCIpO1xuICAgIGNvbnN0IG92ZXJsYXlfaW5zdHIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm92ZXJsYXlcIik7XG4gICAgbW9kYWxfaW5zdHIuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiKTtcbiAgICBvdmVybGF5X2luc3RyLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIik7XG59XG5mdW5jdGlvbiBUaW1lRWxhcHNlZCgpIHtcbiAgICBlbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHRpbWVUYWtlbiA9IE1hdGguZmxvb3IoKGVuZF90aW1lIC0gc3RhcnRfdGltZSkgLyAxMDAwKTtcbiAgICByZXR1cm4gdGltZVRha2VuO1xufVxud2luZG93Lm9ubG9hZCA9ICgpID0+IHtcbiAgICBpbml0aWFsaXNlTWF6ZSg1MDAsIDEwLCAxMCk7XG4gICAgdG9nZ2xlSW5zdHJNb2RhbCgpO1xuICAgIC8vIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIikgYXMgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAvLyBsZXQgYyA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG59O1xuZnVuY3Rpb24gcmVsb2FkKCkge1xuICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"]();
/******/ 	
/******/ })()
;